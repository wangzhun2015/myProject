package com.bskj.demo;
public class C {  
    public static void main(String[] args) {  
        int a=129;  
        //              第一组         第二组        第三组         第四组  
        //2的二进制表示完整为 "[00000000][00000000][00000000][00000010]"[]括号实际没有，为了看起来清楚加的  
        byte[] b=new byte[4];  
        //向右移位是   低位舍弃，高位补符号位  
        //向右移位运算，移动24位后，高8位，被移动到低8位上，二、三、四组都会被丢弃    
        b[0]=(byte) (a>>24);  
        //向右移动16位，高16位到低16位地方，第三、四组会被舍弃，至于&0xff这里不容易看出来，b[3]那一行能看出来  
        b[1]=(byte) ((a>>16)&0xff);  
        //移动8位第四组会被丢弃，结果还是0  
        b[2]=(byte) ((a>>8)&0xff);  
        //不移动直接进行与（&）运算，0xff的二进制是第四位为8个1 其他是0的数，作用就是排除不想要的位  
        //这里来个例子 [00000000][00000110][00000100][00000010]假如有这么个二进制的数字  
        //如果你想取到[00000100]字节的值 ， 先对其向右移动8位变为  
        //[00000000][00000000][00000110][00000100]  
        //然后和0xff与运算,0xff二进制[00000000][00000000][00000000][11111111]  
        //与运算后的结果就为[00000000][00000000][00000000][00000100]  
        //这样需要的字节就拿到了  
        b[3]=(byte) (a&0xff);  
        for (byte c : b) {  
            System.out.print(Integer.toBinaryString(c&0xff)+" ");  
        }  
        System.out.println();  
        //把字节转回Int和上面颠倒下，就不多说了。  
        int i=0;  
        i+=((b[0]&0xff)<<24);  
        i+=((b[1]&0xff)<<16);  
        i+=((b[2]&0xff)<<8);  
        i+=((b[3]&0xff));  
        System.out.println(i);  
    }  
} 